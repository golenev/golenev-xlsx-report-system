# User Stories

## ✅ UI User Stories

### UI-1. Добавление новой строки

- Пользователь создаёт черновую строку через кнопку **Add Row**; при наличии пустого черновика или активного режима редактирования кнопка блокируется.
- В столбце **Test ID** вводится уникальное значение (триммируется). Если ID уже есть среди сохранённых строк или других черновиков, появляется попап «Duplicate Test ID …» и сохранение запрещено.
- При сохранении проверяются обязательные поля: `Test ID`, `Category`, `Short Title`, `Scenario`. Для каждого пустого поля показывается сообщение вида «Required field <fieldName>».
- Остальные поля заполняются по желанию; Priority по умолчанию — `Medium`, `Notes` по умолчанию пустые, `Issue Link` заполнен базовым префиксом.

### UI-2. Фиксация Ready Date

- Ready Date отображается как read-only значение, выставляемое сервером при первом сохранении строки.
- При последующем редактировании значение Ready Date никогда не меняется.

### UI-3. Редактирование существующих записей

- Test ID не редактируется.
- Остальные поля редактируются инлайн; сохранение происходит по блюру ячейки или при выборе значения в выпадающем списке. UI всегда отправляет изменения с `forceUpdate=true`, чтобы разрешить обновление ручных полей (Issue Link, General Status, Priority, Notes).
- Пока строка находится в режиме редактирования, кнопка **Add Row** остаётся заблокированной.
- Поле **General Test Status** заполняется только валидными статусами из списка, **Priority** выбирается из фиксированного набора.

### UI-4. Удаление записи

- Кнопка ✕ удаляет строку после подтверждения диалога браузера. При успешном удалении таблица перезагружается.

### UI-5. Сортировка таблицы

- Таблица всегда отсортирована по **Test ID**: сначала по числовой части, затем по суффиксу после дефиса, затем по лексикографическому порядку.
- После добавления, изменения или удаления сортировка применяется автоматически.

### UI-6. Экспорт данных

- Кнопка **Export to Excel** выгружает текущие данные таблицы с сохранением ширин колонок из конфигурации.

### UI-7. Управление регрессом

- В заголовке колонки **Regress Run** доступно управление регрессионным прогоном.
- Запуск требует указать `Release name`; если регресс уже запущен, кнопка запуска недоступна.
- Пока регресс в статусе **RUNNING**, колонка Regress Run разблокирована: для каждой строки выбираются статусы `PASSED`/`FAILED`/`SKIPPED`.
- Попытка остановить регресс при незаполненных статусах показывает предупреждение и блокирует завершение.
- Остановка сохраняет результаты и снова блокирует колонку; отмена сбрасывает состояние до **IDLE** без сохранения результатов.

## ✅ API User Stories

### API-1. Получение списка тестов

- `GET /api/tests` возвращает отсортированный список тестов и объект `columnConfig` с ширинами колонок.

### API-2. Создание или обновление теста

- `POST /api/tests` принимает JSON с полями тест-кейса; обязательны только `testId`, `category`, `shortTitle`, `scenario`.
- Обязательность `runStatus` зависит от параметра `isRegressRunning` (см. ниже).
- Остальные поля могут опускаться; на первом сохранении сервер задаёт дефолты (`readyDate`=сегодня, `issueLink` с базовым префиксом, `generalStatus`="Готово", `priority`="Medium", `notes`="", `updatedAt`=текущее время).
- При последующих апдейтах сервер всегда перезаписывает обязательные поля (`category`, `shortTitle`, `scenario`), но `testId` и `readyDate` неизменяемы.
- Ручные поля (`issueLink`, `generalStatus`, `priority`, `notes`) меняются только если передан `forceUpdate=true` и поле присутствует в теле запроса; при `forceUpdate=false` эти поля не трогаются.
- Значения `generalStatus` и `priority` валидируются по предопределённым справочникам; при ошибке возвращается 400 с описанием.

### API-3. Пакетная загрузка

- `POST /api/tests/batch?isRegressRunning={true|false}&forceUpdate={true|false}` применяет ту же логику upsert, параметры управляют поведением ручных полей и `runStatus`.

### API-4. Обработка дубликатов Test ID

- При передаче существующего `testId` запись обновляется без ошибки; `readyDate` при этом не меняется, `testId` не обновляется.
- Отсутствие `testId` возвращает 400 с сообщением `Required field testId is missing`.

### API-5. Управление Ready Date

- При создании `readyDate` всегда выставляется сервером в текущую дату и хранится как неизменяемая.
- При обновлении `readyDate` игнорируется даже если значение передано в запросе.

### API-6. Upsert с управлением регрессом и ручными полями

- Параметр `isRegressRunning` влияет только на `runStatus`: при `true` поле обязательно и обновляется; при `false` игнорируется даже если пришло в теле.
- Параметр `forceUpdate` управляет изменением ручных полей (`issueLink`, `generalStatus`, `priority`, `notes`): при `false` они не трогаются, при `true` обновляются только если присутствуют в теле запроса.
- Параметр `forceUpdate` из UI всегда равен `true`, чтобы позволить редактирование ручных полей.

### API-7. Удаление теста

- `DELETE /api/tests/{testId}` удаляет запись; при отсутствии теста возвращает 404.

### API-8. Экспорт в Excel

- `GET /api/tests/export/excel` отдаёт файл XLSX с данными и ширинами колонок из конфигурации.

### API-9. Управление регрессом

- `POST /api/regressions/start` стартует прогон: требуется непустой `releaseName`, отсутствие другого запущенного регресса и уникальность имени релиза.
- `POST /api/regressions/stop` завершает прогон только при статусе **RUNNING** и наличия статуса для каждого теста из списка; допустимые значения — `PASSED`/`FAILED`/`SKIPPED`.
- `POST /api/regressions/cancel` отменяет запущенный прогон и переводит состояние в **IDLE** (если результаты не сохранялись, запись удаляется).
- Результаты остановленного прогона сохраняют метаданные (`regressionDate`, `releaseName`) и статусы всех тестов.

### API-10. Текущее состояние регресса

- `GET /api/regressions/current` возвращает статус (`RUNNING`/`COMPLETED`/`IDLE`), дату регресса, имя релиза и ранее сохранённые результаты для запущенного прогона.

### API-11. Конфигурация колонок

- `GET /api/config/columns` отдаёт ширины колонок, которые применяются в UI и при экспорте.
