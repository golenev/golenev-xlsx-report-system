# User Stories

## ✅ UI User Stories

### UI-1. Добавление новой строки

- Пользователь создаёт черновую строку через кнопку **Add Row**; при наличии пустого черновика или активного режима редактирования кнопка блокируется.
- В столбце **Test ID** вводится уникальное значение (триммируется). Если ID уже есть среди сохранённых строк или других черновиков, появляется попап «Duplicate Test ID …» и сохранение запрещено.
- При сохранении проверяются обязательные поля: `Test ID`, `Category`, `Short Title`, `Scenario`. Для каждого пустого поля показывается сообщение вида «Required field <fieldName>».
- Остальные поля заполняются по желанию; Priority по умолчанию — `Medium`, `Notes` по умолчанию пустые, `Issue Link` заполнен базовым префиксом.

### UI-2. Фиксация Ready Date

- Ready Date отображается как read-only значение, выставляемое сервером при первом сохранении строки.
- При последующем редактировании значение Ready Date обновляется только если в запросе есть `forceUpdate=true` и передано новое значение даты (для серверных правок); UI по умолчанию не даёт редактировать поле.

### UI-3. Редактирование существующих записей

- Test ID не редактируется.
- Остальные поля редактируются инлайн; сохранение происходит по блюру ячейки или при выборе значения в выпадающем списке. UI всегда отправляет изменения с `forceUpdate=true`, чтобы разрешить обновление ручных полей (Issue Link, General Status, Priority, Notes).
- Пока строка находится в режиме редактирования, кнопка **Add Row** остаётся заблокированной.
- Поле **General Test Status** заполняется только валидными статусами из списка, **Priority** выбирается из фиксированного набора.

### UI-4. Удаление записи

- Кнопка ✕ удаляет строку после подтверждения диалога браузера. При успешном удалении таблица перезагружается.

### UI-5. Сортировка таблицы

- Таблица всегда отсортирована по **Test ID**: сначала по числовой части, затем по суффиксу после дефиса, затем по лексикографическому порядку.
- После добавления, изменения или удаления сортировка применяется автоматически.

### UI-6. Экспорт данных

- Кнопка **Export to Excel** выгружает текущие данные таблицы с сохранением ширин колонок из конфигурации.

### UI-7. Управление регрессом

- В заголовке колонки **Regress Run** доступно управление регрессионным прогоном.
- Запуск требует указать непустой `Release name`; если регресс уже запущен или имя релиза совпадает с уже существующим снапшотом, кнопка запуска недоступна.
- Пока регресс в статусе **RUNNING**, колонка Regress Run разблокирована: для каждой строки выбираются статусы `PASSED`/`FAILED`/`SKIPPED`.
- Попытка остановить регресс при незаполненных статусах показывает предупреждение и блокирует завершение.
- Остановка сохраняет результаты и снова блокирует колонку; отмена сбрасывает состояние до **IDLE** без сохранения результатов.

### UI-8. Аналитика по релизам

- В правой панели отображается виджет **Release Analytics** с раскрывающимся списком релизов.
- Виджет загружает список релизов и готовность по каждому через `/api/regressions/releases`, автоматически выбирая первый доступный релиз.
- При выборе релиза запрашивается снапшот `/api/regressions/{releaseId}` и строятся метрики: процент автоматизации (`Готово`), количество `Passed/Failed`, статусы очереди/в работе.
- При ошибке загрузки отображается предупреждение, при пустом списке релизов показывается заглушка «Нет доступных релизов».

## ✅ API User Stories

### API-1. Получение списка тестов

- `GET /api/tests` возвращает отсортированный список тестов и объект `columnConfig` с ширинами колонок.

### API-2. Создание или обновление теста

- `POST /api/tests` принимает JSON с полями тест-кейса; обязательны только `testId`, `category`, `shortTitle`, `scenario`.
- Обязательность `runStatus` зависит от параметра `isRegressRunning` (см. ниже).
- Остальные поля могут опускаться; на первом сохранении сервер задаёт дефолты (`readyDate`=сегодня, `issueLink` с базовым префиксом, `generalStatus`="Готово", `priority`="Medium", `notes`="", `updatedAt`=текущее время).
- При последующих апдейтах сервер всегда перезаписывает обязательные поля (`category`, `shortTitle`, `scenario`), но `testId` неизменяем; `readyDate` можно изменить только с `forceUpdate=true` и явно переданным значением.
- Ручные поля (`issueLink`, `generalStatus`, `priority`, `notes`) меняются только если передан `forceUpdate=true` и поле присутствует в теле запроса; при `forceUpdate=false` эти поля не трогаются.
- Значения `generalStatus` и `priority` валидируются по предопределённым справочникам; при ошибке возвращается 400 с описанием.
- При одиночном вызове `/api/tests` отсутствие обязательных полей может покрываться значениями из уже сохранённой записи (fallback), но при создании новой записи их отсутствие приводит к 400.

### API-3. Пакетная загрузка

- `POST /api/tests/batch?isRegressRunning={true|false}&forceUpdate={true|false}` применяет ту же логику upsert, параметры управляют поведением ручных полей и `runStatus`.
- При `isRegressRunning=true` перед загрузкой проверяется актуальный запущенный регресс; при отсутствии активного регресса возвращается 404.

### API-4. Обработка дубликатов Test ID

- При передаче существующего `testId` запись обновляется без ошибки; `testId` не обновляется, `readyDate` сохраняется, если только явно не передан новый `readyDate` с `forceUpdate=true`.
- Отсутствие `testId` возвращает 400 с сообщением `Required field testId is missing`.

### API-5. Управление Ready Date

- При создании `readyDate` всегда выставляется сервером в текущую дату и хранится как read-only для UI.
- При обновлении `readyDate` принимается только если передан `forceUpdate=true` и корректный формат даты; без флага игнорируется.

### API-6. Upsert с управлением регрессом и ручными полями

- Параметр `isRegressRunning` влияет только на `runStatus`: при `true` поле обязательно и обновляется; при `false` игнорируется даже если пришло в теле.
- Параметр `forceUpdate` управляет изменением ручных полей (`issueLink`, `generalStatus`, `priority`, `notes`): при `false` они не трогаются, при `true` обновляются только если присутствуют в теле запроса.
- Параметр `forceUpdate` из UI всегда равен `true`, чтобы позволить редактирование ручных полей.
- При пакетной загрузке во время регресса статусы `runStatus` синхронизируются с текущим регрессом и добавляются в его payload.

### API-7. Удаление теста

- `DELETE /api/tests/{testId}` удаляет запись; при отсутствии теста возвращает 404.

### API-8. Экспорт в Excel

- `GET /api/tests/export/excel` отдаёт файл XLSX с данными и ширинами колонок из конфигурации.

### API-9. Управление регрессом

- `POST /api/regressions/start` стартует прогон: требуется непустой `releaseName` (обрезается по краям), отсутствие другого запущенного регресса и уникальность имени релиза среди всех регрессов.
- `POST /api/regressions/stop` завершает прогон только при статусе **RUNNING** и наличия статуса для каждого теста из списка; допустимые значения — `PASSED`/`FAILED`/`SKIPPED`.
- `POST /api/regressions/cancel` отменяет запущенный прогон и переводит состояние в **IDLE** (если результаты не сохранялись, запись удаляется).
- Результаты остановленного прогона сохраняют метаданные (`regressionDate`, `releaseName`) и статусы всех тестов.

### API-9.1. История регрессов

- `GET /api/regressions/releases` возвращает список релизов с их `id`, `name`, датой и статусом, отсортированный по дате убывания.
- `GET /api/regressions/{regressionId}` отдаёт сохранённый снапшот регресса (включая тесты и метаданные); 404 если нет записи.
- `GET /api/regressions/{regressionId}/snapshot.xlsx` скачивает XLSX с результатами конкретного регресса; если снапшот пустой, возвращается 400.

### API-10. Текущее состояние регресса

- `GET /api/regressions/current` возвращает статус (`RUNNING`/`COMPLETED`/`IDLE`), дату регресса, имя релиза и ранее сохранённые результаты для запущенного прогона.

### API-11. Конфигурация колонок

- `GET /api/config/columns` отдаёт ширины колонок, которые применяются в UI и при экспорте.
