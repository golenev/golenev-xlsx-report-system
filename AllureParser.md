# Импорт отчётов Allure из `allure-results`

## Выбор папки в браузере
1. На фронте используется `<input type="file" webkitdirectory multiple>` без фильтрации по расширению.
2. Пользователь выбирает целиком каталог `build/allure-results`.
3. Все файлы из выбранной папки (включая вложения) попадают в состояние и дальше в запрос.

## Формирование multipart на фронте
- Поле `files[]` заполняется всеми полученными файлами.
- Для каждого файла дополнительно передаётся `paths[]` со значением `file.webkitRelativePath` (или именем файла, если путь недоступен).
- Параметры `isRegressRunning` и `forceUpdate` остаются без изменений.
- Соответствие `files[i]` ↔ `paths[i]` сохраняется по индексу.

## Приём multipart на бэкенде
- Эндпоинт `POST /uploadReport` принимает `files[]`, опциональные `paths[]` и параметры `isRegressRunning`, `forceUpdate`.
- Каждый элемент превращается в `AllureUpload(path: String, content: ByteArray)` с сохранением относительного пути.
- Формируется индекс `filesByName`, где ключ — basename файла (без каталогов), значение — содержимое.

## Отбор JSON для парсинга
- Рассматриваются только JSON, которые выглядят как тест-кейсы (`name`, `status`/`testStage`/`steps`).
- Основной источник — `*-result.json`; `*-container.json`, `executor.json` и прочие файлы игнорируются для построения сценариев.
- Если тестовых JSON нет, возвращается ошибка 400.

## Формирование ID
- Базовое значение берётся из лейбла `AS_ID` (например, `455`).
- Если в одном отчёте несколько прогонов с одинаковым `AS_ID` (параметризованные тесты), к базовому значению добавляется динамический постфикс `-<номер>`: `455-1`, `455-2` и т.д.
- Такой постфикс позволяет различать отдельные прогоны без изменения исходного `AS_ID` в коде автотеста.

## Построение сценариев
- Сценарий собирается из `testStage.steps` или fallback `steps` в `*-result.json` с рекурсивным обходом.
- Нумерация шагов и вывод параметров сохраняют прежний формат.
- Шаги больше не фильтруются по слову `attachments` в названии.

## Подшивка attachments в шаги
1. Для каждого шага читается список `attachments`.
2. Attachment ищется в `filesByName` по `source` (basename).
3. Если файл не найден — добавляется строка `[Attachment missing] <name> -> <source>`.
4. Если найден:
   - Определяется тип вложения.
   - Текстовые вложения встраиваются как plain text под шагом.
   - Бинарные вложения отображаются как `[binary attachment: <type>; file=<source>; size=<n>]`.
5. Формат вставки:
   ```
   Attachment: Request (abc-attachment.html)
     <content>
   ```

## Правила классификации вложений
- Текстовые: `type` начинается с `text/` **или** расширение `.html`, `.txt`, `.log`, `.json`, `.xml`.
- HTML обрабатывается как текст (см. ниже).
- Остальные считаются бинарными.

## Обработка HTML → text
- Удаляются `<script>` и `<style>` блоки.
- `<br>`, `</p>`, `</div>`, `</pre>` заменяются на переводы строки.
- Любые другие теги удаляются.
- HTML entities декодируются, результат обрезается по краям.

## Ограничения на содержимое
- Дополнительного маскирования заголовков нет: вложения выводятся как есть, поэтому источник данных должен быть доверенным.
- Максимальный размер текста вложения — `MAX_ATTACHMENT_CHARS` (50_000). Всё сверх лимита отбрасывается с суффиксом `...TRUNCATED...`.

## Поведение при отсутствии вложений
- Если загружены только JSON-файлы, пишется WARN `Attachments files not provided; scenario will not include request/response`, сценарии собираются без вложений (как раньше).
- Если вложение указано в JSON, но файл не найден, в сценарий добавляется метка `[Attachment missing]`.
